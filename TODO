TODO:
	Finish Consensus Stuff:
		   - confirmations with quorum set stuff
		   - creating/sending messages appropriately
	Proposer Function to make new ballots
             - Verify nonces on receipt of new ballot for first time
               * What are the places to verify>
               * Dynamic difficulty?
	Writeup Paper:
            - Polishing
	State Machine
	Node/Network:
		Being able to join at any time/bootstrap
	Message
	FakeRPCLayer -> TCPRPCLayer or UDPRPCLayer or Byzantine RPC Layer
				 - Resending
				 - Signing messages
				 - Forwarding messages
				 - Peering
				 - memcpy messages in fakerpc layer!
	Memory Management


        


DONE:
	Finish Consensus Stuff:
		   - incrementing ballots? -- Pretty sure (JHH)
       - only broadcast messages to your peers
       - only let messages from your peers change your state.
	Proposer Function to make new ballots
			 - Picking a slot
			 - Use light HashCash for random timeouts?
	Writeup Paper:
			- Journey into Stellar/Our summary of how the protocol works
			- Design overview
                + Why we chose C++
				+ What we got done/what is left
				+ paste in consensus critical code
	State Machine
		  - Key Value store
			* Append
	Node/Network:
	Message
        serialize
		Change RPC Layer Queue to be using json strings
	FakeRPCLayer -> TCPRPCLayer or UDPRPCLayer or Byzantine RPC Layer
	Memory Management
		   - Clean up memory leaks :: Would be good to do
